# Общее

1. Разрешить непривелигерованному пользователю считать метрики:
```bash
sudo sysctl kernel.perf_event_paranoid=2
```
1. Стабилизация результатов.
   Надо выделить отдельный процессор (скажем, 7) и запускаться только на нём. Мешаются CPU Scaling и шедулер.
   1. Выставляем cpu7 на максимальную частоту:
   ```bash
   sudo cpupower -c 7 frequency-set -g performance
   ```
   1. Создаём shield на седьмом процессоре, чтобы туда никто не залезал
   ```bash
   sudo cset shield --cpu 7 --kthread=on
   ```
   1. Запускаем пример внутри shield
   ```bash
   sudo cset shield --exec ./01-lcg-random-no-unroll
   ```
1. Кажется, у CMake есть баг: когда меняешь компилятор, надо запускаться два раза.

# Частное

## `01-lcg-random`

* Инты точно такие же по скорости инструкций, как лонги.
* Всё влезает в регистры, инструкции простые, поэтому по инструкции на такт.
* Умножения и сложения работают одинаково быстро.
* В g++ выключен `-funroll-loops` даже с `-O3`, а в clang++ включен и в `-O2`. Поэтому по умолчанию у g++ цикл занимает 4 процессорных инструкции, а у кланга -- половину (так как анроллит он восемь итераций). Если мануально выключить `-funroll-loops`, у обоих будет по 4. Если мануально включить, то у кланга будет по половине, а у g++ половина для интов и одна для лонгов, потому что лонги он анроллит в шесть инструкций, а не в четыре, как кланг. Для меня всё ещё загадка, почему выгодит одна, а не 0.75.


