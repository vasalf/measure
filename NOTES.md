# Общее

1.  `perf_event_paranoid`
```
# echo 2 > /proc/sys/kernel/perf_event_paranoid 
```
1. Чтобы добиться стабильных результатов по времени, надо делать вормапы (примерно одну секунду).
   1. Виноват ли здесь шедулер? Если да, можно ли дать ему подсказку чтобы не надо было?
   1. Компилятор норовит их выкинуть, поэтому их результат надо как-то использовать.
1. Кажется, на зарядке ноут производительнее: ~0.25 νs на такт против ~0.325 νs.
1. Кажется, у CMake есть баг: когда меняешь компилятор, надо запускаться два раза.

# Частное

## `01-lcg-random`

* Инты точно такие же по скорости инструкций, как лонги.
* Всё влезает в регистры, инструкции простые, поэтому по инструкции на такт.
* Умножения и сложения работают одинаково быстро.
* В g++ выключен `-funroll-loops` даже с `-O3`, а в clang++ включен и в `-O2`. Поэтому по умолчанию у g++ цикл занимает 4 процессорных инструкции, а у кланга -- половину (так как анроллит он восемь итераций). Если мануально выключить `-funroll-loops`, у обоих будет по 4. Если мануально включить, то у кланга будет по половине, а у g++ половина для интов и одна для лонгов, потому что лонги он анроллит в шесть инструкций, а не в четыре, как кланг. Для меня всё ещё загадка, почему выгодит одна, а не 0.75.


